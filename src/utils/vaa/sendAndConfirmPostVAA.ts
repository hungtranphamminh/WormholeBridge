// import { isBytes } from "@ethersproject/bytes";
// import { Connection, Keypair, PublicKeyInitData } from "@solana/web3.js";
// import { parseVaa } from "./parser";

// /** Send transactions for `verify_signatures` and `post_vaa` instructions.
//  *
//  * Using a signed VAA, execute transactions generated by {@link verifySignatures} and
//  * {@link postVaa}. At most 4 transactions are sent (up to 3 from signature verification
//  * and 1 to post VAA data to an account).
//  *
//  * @param {Connection} connection - Solana web3 connection
//  * @param {PublicKeyInitData} wormholeProgramId - wormhole program address
//  * @param {web3.Keypair} payer - transaction signer address
//  * @param {Buffer} signedVaa - bytes of signed VAA
//  * @param {Commitment} [options] - Solana commitment
//  *
//  */
// export function createPostSignedVaaTransactions(connection:Connection, wormholeProgramId:string, payer:string, vaa:any, commitment=5) {
//     const parsed = isBytes(vaa) ? parseVaa(vaa) : vaa;
//     const signatureSet = Keypair.generate();
//     const verifySignaturesInstructions = createVerifySignaturesInstructions(connection, wormholeProgramId, payer, parsed, signatureSet.publicKey, commitment);
//     // const unsignedTransactions = [];
//     // for (let i = 0; i < verifySignaturesInstructions.length; i += 2) {
//     //     unsignedTransactions.push(new Transaction().add(...verifySignaturesInstructions.slice(i, i + 2)));
//     // }
//     // unsignedTransactions.push(new Transaction().add(createPostVaaInstruction(wormholeProgramId, payer, parsed, signatureSet.publicKey)));
//     // return {
//     //     unsignedTransactions,
//     //     signers: [signatureSet],
//     // };
// }

// /**
//  * This is used in {@link createPostSignedVaaTransactions}'s initial transactions.
//  *
//  * Signatures are batched in groups of 7 due to instruction
//  * data limits. These signatures are passed through to the Secp256k1
//  * program to verify that the guardian public keys can be recovered.
//  * This instruction is paired with `verify_signatures` to validate the
//  * pubkey recovery.
//  *
//  * There are at most three pairs of instructions created.
//  *
//  * https://github.com/certusone/wormhole/blob/main/solana/bridge/program/src/api/verify_signature.rs
//  *
//  *
//  * @param {Connection} connection - Solana web3 connection
//  * @param {PublicKeyInitData} wormholeProgramId - wormhole program address
//  * @param {PublicKeyInitData} payer - transaction signer address
//  * @param {SignedVaa | ParsedVaa} vaa - either signed VAA bytes or parsed VAA (use {@link parseVaa} on signed VAA)
//  * @param {PublicKeyInitData} signatureSet - address to account of verified signatures
//  * @param {web3.ConfirmOptions} [options] - Solana confirmation options
//  */
// export function createVerifySignaturesInstructions(connection:Connection, wormholeProgramId:string, payer:string, vaa:any, signatureSet:PublicKeyInitData, commitment:any) {
//     const parsed = isBytes(vaa) ? parseVaa(vaa) : vaa;
//     const guardianSetIndex = parsed.guardianSetIndex;
//     const info = await getWormholeBridgeData(connection, wormholeProgramId);
//     // if (guardianSetIndex != info.guardianSetIndex) {
//     //     throw new Error("guardianSetIndex != config.guardianSetIndex");
//     // }
//     // const guardianSetData = yield getGuardianSet(connection, wormholeProgramId, guardianSetIndex, commitment);
//     // const guardianSignatures = parsed.guardianSignatures;
//     // const guardianKeys = guardianSetData.keys;
//     // const batchSize = 7;
//     // const instructions = [];
//     // for (let i = 0; i < Math.ceil(guardianSignatures.length / batchSize); ++i) {
//     //     const start = i * batchSize;
//     //     const end = Math.min(guardianSignatures.length, (i + 1) * batchSize);
//     //     const signatureStatus = new Array(MAX_LEN_GUARDIAN_KEYS).fill(-1);
//     //     const signatures = [];
//     //     const keys = [];
//     //     for (let j = 0; j < end - start; ++j) {
//     //         const item = guardianSignatures.at(j + start);
//     //         signatures.push(item.signature);
//     //         const key = guardianKeys.at(item.index);
//     //         keys.push(key);
//     //         signatureStatus[item.index] = j;
//     //     }
//     //     instructions.push(createSecp256k1Instruction(signatures, keys, parsed.hash));
//     //     instructions.push(createVerifySignaturesInstruction(wormholeProgramId, payer, parsed, signatureSet, signatureStatus));
//     // }
//     // return instructions;
// }

// export function getWormholeBridgeData(connection:Connection, wormholeProgramId:string, commitment:any) {
//     return connection
//         .getAccountInfo(deriveWormholeBridgeDataKey(wormholeProgramId), commitment)
//         .then((info) => BridgeData.deserialize(getAccountData(info)));
// }